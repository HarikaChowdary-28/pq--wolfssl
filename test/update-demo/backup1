aes-file-encrypt.c

#include <stdio.h>
#include <unistd.h>
#include <termios.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_CONFIG_H
    #include <config.h>
#endif
#ifndef WOLFSSL_USER_SETTINGS
    #include <wolfssl/options.h>
#endif
/*wolfssl*/
#include <wolfssl/wolfcrypt/settings.h>
#include <wolfssl/wolfcrypt/asn_public.h>
#include <wolfssl/wolfcrypt/asn.h>
#include <wolfssl/ssl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <wolfssl/wolfcrypt/aes.h>
#include <wolfssl/wolfcrypt/sha256.h>
#include <wolfssl/wolfcrypt/random.h>
#include <wolfssl/wolfcrypt/pwdbased.h>

#if defined(HAVE_PBKDF2) && !defined(NO_PWDBASED)

#define KEY_SIZE 32 // 256 bits key size
#define SALT_SIZE 8

/*
 * Generates a cryptographically secure key by stretching a user entered key
 */
int GenerateKey(WC_RNG* rng, byte* key, int size, byte* salt, int pad)
{
    int ret;

    ret = wc_RNG_GenerateBlock(rng, salt, SALT_SIZE);
    if (ret != 0)
        return -1020;

    if (pad == 0)
        salt[0] = 0;
    /* salt[0] == 0 should only be used if pad == 0 */
    else if (salt[0] == 0)
        salt[0] = 1;

    /* stretches key */
    ret = wc_PBKDF2(key, key, strlen((const char*)key), salt, SALT_SIZE, 4096,
        size, WC_SHA256);
    if (ret != 0)
        return -1030;

    return 0;
}

/*
 * Encrypts a file using AES
 */
int AesEncrypt(Aes* aes, byte* key,int size, FILE* inFile, FILE* outFile)
{
    WC_RNG     rng;
    byte    iv[AES_BLOCK_SIZE];
    byte*   input;
    byte*   output;
    byte    salt[SALT_SIZE] = {0};

    int     ret = 0;
    int     inputLength;
    int     length;
    int     padCounter = 0;

    fseek(inFile, 0, SEEK_END);
    inputLength = ftell(inFile);
    fseek(inFile, 0, SEEK_SET);

    length = inputLength;
    /* pads the length until it evenly matches a block / increases pad number*/
    while (length % AES_BLOCK_SIZE != 0) {
        length++;
        padCounter++;
    }

    input = malloc(length);
    output = malloc(length);

    ret = wc_InitRng(&rng);
    if (ret != 0) {
        printf("Failed to initialize random number generator\n");
        return -1030;
    }

    /* reads from inFile and writes whatever is there to the input array */
    ret = fread(input, 1, inputLength, inFile);
    if (ret == 0) {
        printf("Input file does not exist.\n");
        return -1010;
    }
    for (int i = inputLength; i < length; i++) {
        /* pads the added characters with the number of pads */
        input[i] = padCounter;
    }

    ret = wc_RNG_GenerateBlock(&rng, iv, AES_BLOCK_SIZE);
    if (ret != 0)
        return -1020;

    /* generate and stretch key */
    ret = GenerateKey(&rng, key, KEY_SIZE, salt, padCounter);
    if (ret != 0)
        return -1040;

    /* set key */
    ret = wc_AesSetKey(aes, key, KEY_SIZE, iv, AES_ENCRYPTION);
    if (ret != 0)
        return -1001;

    /* encrypts the message to the output based on input length + padding */
    ret = wc_AesCbcEncrypt(aes, output, input, length);
    if (ret != 0)
        return -1005;

    /* writes salt, iv, and encrypted data to outFile */
    fwrite(salt, 1, SALT_SIZE, outFile);
    fwrite(iv, 1, AES_BLOCK_SIZE, outFile);
    fwrite(output, 1, length, outFile);

    /* closes the opened files and frees the memory*/
    memset(input, 0, length);
    memset(output, 0, length);
    fclose(inFile);
    fclose(outFile);
    wc_FreeRng(&rng);

    return ret;
}

int main()
{
    Aes aes;
    byte key[KEY_SIZE]; // Fixed key size

    // Open key file
    FILE* keyFile = fopen("sharedkeys/kyber_shared_secret_1.txt", "rb");
    if (keyFile == NULL) {
        printf("Error: Unable to open key file.\n");
        return -1;
    }

    // Read the key from the file
    if (fread(key, 1, KEY_SIZE, keyFile) != KEY_SIZE) {
        printf("Error: Unable to read key from file.\n");
        fclose(keyFile);
        return -1;
    }

    fclose(keyFile);

    FILE* inFile = fopen("input.txt", "rb");
    if (inFile == NULL) {
        printf("Error: Unable to open input file.\n");
        return -1;
    }

    FILE* outFile = fopen("output.txt", "wb");
    if (outFile == NULL) {
        printf("Error: Unable to open output file.\n");
        fclose(inFile);
        return -1;
    }

    int ret = AesEncrypt(&aes, key, KEY_SIZE, inFile, outFile);
    if (ret != 0) {
        printf("Encryption failed with error code %d\n", ret);
    } else {
        printf("Encryption successful.\n");
    }

    return ret;
}
#endif

------------------------------

hmac-generate.c

#include <stdio.h>
#include <unistd.h>
#include <termios.h>
#include <stdlib.h>
#include <string.h>
#ifdef HAVE_CONFIG_H
    #include <config.h>
#endif
#ifndef WOLFSSL_USER_SETTINGS
    #include <wolfssl/options.h>
#endif
#include <wolfssl/wolfcrypt/sha256.h>
#include <wolfssl/wolfcrypt/hmac.h>
#include <wolfssl/wolfcrypt/random.h>
#include <wolfssl/ssl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <wolfssl/wolfcrypt/error-crypt.h>
#include <stdio.h>

int main() {
    int ret = 0;
     WC_RNG     rng;
     byte hmacKey[32];  // HMAC-SHA-256 key is 32 bytes long

    if (wolfCrypt_Init() != 0) {
        //printf("wolfCrypt_Init failed\n");
        return -1;
    }

    if (wc_InitRng(&rng) != 0) {
        //printf("wc_InitRng failed\n");
        return -1;
    }

    if (wc_RNG_GenerateBlock(&rng, hmacKey, sizeof(hmacKey)) != 0) {
        //printf("wc_RNG_GenerateBlock failed\n");
        ret = -1;
    } else {
        //printf("Generated HMAC-SHA-256 Key: ");
        for (int i = 0; i < sizeof(hmacKey); i++) {
            printf("%02x", hmacKey[i]);
        }
        printf("\n");
    }

    wc_FreeRng(&rng);
    wolfCrypt_Cleanup();

    return ret;
}


------------------------------
hmacex_file.c
#include <wolfssl/wolfcrypt/hmac.h>
#include <wolfssl/wolfcrypt/settings.h>
#include <wolfssl/wolfcrypt/sha256.h>
#include <stdio.h>
#include <stdlib.h> // Add this for memory allocation
#include <string.h> // Add this for string manipulation

#ifndef CHUNK_SIZE
#define CHUNK_SIZE 1024
#endif

#ifndef NO_SHA256
#ifndef NO_HMAC

void usage(void) {
    printf("Usage: ./hmac-example <keyfile> <file to hash>\n");
    exit(-99);
}

int main(int argc, char** argv) {
    int ret = -1;
    Hmac hmac;
    byte* key = NULL; // Change the key to a dynamically allocated buffer
    word32 keyLength;
    byte rawInput[CHUNK_SIZE];
    FILE* inputStream;
    char* fName = NULL;
    int fileLength = 0;
    int i, chunkSz;

    if (argc < 3)
        usage();
    
    // Read the key from the keyfile
    char* keyFilename = argv[1];
    FILE* keyFile = fopen(keyFilename, "r");
    if (keyFile == NULL) {
        perror("Error opening keyfile");
        return -1;
    }

    fseek(keyFile, 0, SEEK_END);
    keyLength = ftell(keyFile) / 2; // Each byte is represented by 2 characters
    fseek(keyFile, 0, SEEK_SET);

    key = (byte*)malloc(keyLength);
    if (key == NULL) {
        perror("Memory allocation failed");
        fclose(keyFile);
        return -1;
    }

    for (i = 0; i < keyLength; i++) {
        if (fscanf(keyFile, "%2hhx", &key[i]) != 1) {
            perror("Error reading keyfile");
            fclose(keyFile);
            free(key);
            return -1;
        }
    }

    fclose(keyFile);

    fName = argv[2];
    //printf("Hash input file %s\n", fName);

    inputStream = fopen(fName, "rb");
    if (inputStream == NULL) {
        printf("ERROR: Unable to open file %s\n", fName);
        free(key);
        return -1;
    }

    /* Find the length of the file */
    fseek(inputStream, 0, SEEK_END);
    fileLength = (int)ftell(inputStream);
    fseek(inputStream, 0, SEEK_SET);

    /* Initialize HMAC context */
    wc_HmacInit(&hmac, NULL, 0); // No initialization required based on provided wc_HmacInit implementation

    /* Loop reading a block at a time, finishing with any excess */
    for (i = 0; i < fileLength; i += CHUNK_SIZE) {
        chunkSz = CHUNK_SIZE;
        if (chunkSz > fileLength - i)
            chunkSz = fileLength - i;

        ret = fread(rawInput, 1, chunkSz, inputStream);
        if (ret != chunkSz) {
            printf("ERROR: Failed to read the appropriate amount\n");
            ret = -1;
            break;
        }

        ret = wc_HmacSetKey(&hmac, WC_SHA256, key, keyLength);

        if (ret != 0) {
            printf("Failed to set the HMAC\n");
            break;
        }

        ret = wc_HmacUpdate(&hmac, rawInput, chunkSz);
        if (ret != 0) {
            printf("Failed to update the HMAC\n");
            break;
        }
    }

    if (ret == 0) {
        byte hmacResult[WC_SHA256_DIGEST_SIZE];
        ret = wc_HmacFinal(&hmac, hmacResult);
        if (ret == 0) {
           // printf("HMAC-SHA-256 result is: ");
            for (i = 0; i < WC_SHA256_DIGEST_SIZE; i++)
                printf("%02x", hmacResult[i]);
            printf("\n");
        }
    }

    if (ret != 0) {
        printf("ERROR: HMAC operation failed\n");
    }

    fclose(inputStream);
    free(key); // Free the allocated key buffer
}
#else
int main(void) {
    printf("HMAC is disabled (NO_HMAC is defined).\n");
    return -1;
}
#endif
#else
int main(void) {
    printf("SHA-256 is disabled (NO_SHA256 is defined).\n");
    return -1;
}
#endif

------------------------------
certgen.sh

#!/bin/bash

# Loop 1000 times
for ((i=1; i<=1000; i++))
do
    # Create directory for the current iteration
    mkdir -p "dilithium/it$i"
    
    # Run your executable here and save files to the created directory
    ./certgen out="dilithium/it$i" root=DILITHIUM 2 ica=DILITHIUM 2 leaf=DILITHIUM 2 
    
    # Optionally, you can add a sleep command if you want to introduce a delay between each run
    # sleep 1
done

---------------

dil-updatesign.c

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#ifdef HAVE_CONFIG_H
    #include <config.h>
#endif
/* wolfSSL */
#include <wolfssl/options.h>
#include <wolfssl/wolfcrypt/settings.h>
#include <wolfssl/wolfcrypt/asn_public.h>
#include <wolfssl/wolfcrypt/asn.h>
#include <wolfssl/ssl.h>
#include <sys/types.h>
#include <sys/stat.h>

#ifndef WOLFSSL_DEBUG_TLS
    #define WOLFSSL_DEBUG_TLS   /* enable full debugging */
#endif
#ifndef DEBUG_WOLFSSL
    #define DEBUG_WOLFSSL
#endif
#ifndef WOLFSSL_CERT_EXT
    #define WOLFSSL_CERT_EXT
#endif
//enable dilithium
// ... All necessary defines ...
#if defined(HAVE_DILITHIUM)
#include <stdint.h>
#include <wolfssl/wolfcrypt/hash.h>
#include <wolfssl/wolfcrypt/dilithium.h>
#include <wolfssl/wolfcrypt/error-crypt.h>
#include <wolfssl/wolfcrypt/dilithium_packing.h>
#include <wolfssl/wolfcrypt/dilithium_polynoms.h>
#include <wolfssl/wolfcrypt/dilithium_symmetric.h>

//define the certificate size, key size
#define BUFFER_SZ 60000    
#define MAX_PEM_CERT_SIZE 60000
#define MAX_DER_KEY_SIZE  60000

//to check if every function is working 
static void check_ret(char *func_name, int ret) {
    if (ret != 0) {
        fprintf(stderr, "ERROR: %s() returned %d\n", func_name, ret);
    }
}

//to write contents to sig file
void write_buffer_to_file(const char* filename, const uint8_t* buffer, size_t len) {
    FILE *file = fopen(filename, "w");
    if (file) {
        for (size_t i = 0; i < len; i++) {
            fprintf(file, "%02x", buffer[i]);
        }
        fclose(file);
    }
}

//to generate a signature for a given msg
int process_signature(const char* cert_file, const char* key_file, const char* msg_file, const char* sig_file) {
    int ret = 0;

    byte pem_buf[MAX_PEM_CERT_SIZE];
    word32 pem_len = sizeof(pem_buf);

    byte priv_der_buf[MAX_DER_KEY_SIZE];
    word32 priv_der_len = sizeof(priv_der_buf);

    byte signature[DILITHIUM_SIG_SIZE];
    word32 signature_len = sizeof(signature); 

    byte file_msg[BUFFER_SZ];
    size_t file_msg_len = 0;

    word32 idx = 0;
    WC_RNG rng;
    DilithiumKey priv_key;

    // Initialize the key and RNG
    ret = wc_InitRng(&rng);
    check_ret("wc_InitRng", ret);

    if (ret == 0) {
        ret = wc_InitDilithiumKey(&priv_key);
        check_ret("wc_InitdilKey", ret);
    }

    // Load the private key
    if (ret == 0) {
        FILE* file = fopen(key_file, "rb");
        if (file) {
            pem_len = fread(pem_buf, 1, sizeof(pem_buf), file);
            fclose(file);
            ret = pem_len > 0 ? 0 : -1;
            check_ret("fread key", ret);
        } else {
            ret = -1;
            check_ret("fopen key", ret);
        }
    }

   // Convert PEM to DER-the key
  if (ret == 0) {
        ret = wc_KeyPemToDer((const byte*)pem_buf, pem_len, 
                  priv_der_buf, priv_der_len, NULL);
        if (ret > 0) {
            priv_der_len = ret;
            ret = 0;
        } else {
            check_ret("wc_KeyPemToDer", ret);
            /* In case ret = 0. */
            ret = -1;
        }
    }
    // Decode the private key by taking the idx value, priv key in der format
    if (ret == 0) {
        ret = wc_DilithiumPrivateKeyDecode(priv_der_buf, &idx, &priv_key, &priv_der_len);
        check_ret("wc_dilPrivateKeyDecode", ret);
    }

    // Load and sign the message 
    if (ret == 0) {
        FILE* msg_file_fp = fopen(msg_file, "rb");
        if (msg_file_fp) {
            file_msg_len = fread(file_msg, 1, BUFFER_SZ, msg_file_fp);
            fclose(msg_file_fp);
            ret = file_msg_len > 0 ? 0 : -1;
            check_ret("fread message", ret);
        } else {
            ret = -1;
            check_ret("fopen message", ret);
        }
    }

    if (ret == 0) {
        //wrapper function to generate a signature by taking msg, msg length , priv key which we decoded from der format and rng. Writes the output buffer (signed message) to signature variable.
        ret = wc_DilithiumSign(signature, (long long unsigned int *)&signature_len, file_msg, file_msg_len, &priv_key, &rng);
        check_ret("wc_dilSign", ret);
    }

    // Write signature to file
    if (ret == 0) {
        write_buffer_to_file(sig_file, signature, signature_len);
        printf("generated signature successfully");
    }
     printf("\n");
    // Free resources
    wc_FreeDilithiumKey(&priv_key);
    wc_FreeRng(&rng);
    wolfCrypt_Cleanup();

    return ret;
}

int main(int argc, char** argv) {
    int ret;

    // Process the first set of files
    clock_t start, end;
    double cpu_time_used;
    start = clock();
    ret = process_signature("servercert.pem", "serverkey.pem", "hmac-encrypted.txt", "upd-sign.txt");
    
    if (ret != 0) return ret;
    end = clock();
    cpu_time_used = ((double) (end - start)) / CLOCKS_PER_SEC;

    printf("Time taken for signature generation: %f seconds\n", cpu_time_used);
    
    //
}
#endif


-------------
certverify

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#ifdef HAVE_CONFIG_H
    #include <config.h>
#endif
/* wolfSSL */
#include <wolfssl/options.h>
#include <wolfssl/wolfcrypt/settings.h>
#include <wolfssl/wolfcrypt/asn_public.h>
#include <wolfssl/wolfcrypt/asn.h>
#include <wolfssl/wolfcrypt/error-crypt.h>
#include <wolfssl/ssl.h>
#include <wolfssl/test.h>
#include <time.h>

#include <sys/types.h>
#include <sys/stat.h>
#define BUFFER_SZ 60000

#ifndef WOLFSSL_DEBUG_TLS
    #define WOLFSSL_DEBUG_TLS  
#endif
#ifndef DEBUG_WOLFSSL
    #define DEBUG_WOLFSSL
#endif
#ifndef WOLFSSL_CERT_EXT
    #define WOLFSSL_CERT_EXT
#endif

#if defined(HAVE_SPHINCS)
    #include <wolfssl/wolfcrypt/sphincs.h>
#endif
#if defined(HAVE_XMSS)
    #include <wolfssl/wolfcrypt/xmss.h>
#endif
#if defined(HAVE_FALCON)
    #include <wolfssl/wolfcrypt/falcon.h>
#endif
#if defined(HAVE_DILITHIUM)
    #include <wolfssl/wolfcrypt/dilithium.h>
#endif
#if defined(HAVE_ECC)
    #include <wolfssl/wolfcrypt/ecc.h>
#endif

int main()
{
    WOLFSSL_X509 *icaCert;
    WOLFSSL_X509 *serverCert;
    WOLFSSL_X509_STORE *store;
    WOLFSSL_X509_STORE_CTX *ctx;
    int verifyResult;

    if (wolfSSL_Init() != SSL_SUCCESS) {
        printf("Error initializing WolfSSL\n");
        return -1;
    }

    
    store = wolfSSL_X509_STORE_new();
    if (store == NULL) {
        printf("Error creating X509 store\n");
        return -1;
    }

    if (wolfSSL_X509_STORE_load_locations(store, "rootcert.pem", NULL) != SSL_SUCCESS) {
        printf("Error loading root CA certificate\n");
        wolfSSL_X509_STORE_free(store);
        return -1;
    }
    icaCert = wolfSSL_X509_load_certificate_file("icacert.pem", SSL_FILETYPE_PEM);
    if (icaCert == NULL) {
        printf("Error loading intermediate CA certificate\n");
        wolfSSL_X509_STORE_free(store);
        return -1;
    }

    serverCert = wolfSSL_X509_load_certificate_file("servercert.pem", SSL_FILETYPE_PEM);
    if (serverCert == NULL) {
        printf("Error loading server certificate\n");
        wolfSSL_X509_STORE_free(store);
        wolfSSL_X509_free(icaCert);
        return -1;
    }

    ctx = wolfSSL_X509_STORE_CTX_new();
    if (ctx == NULL) {
        printf("Error creating X509 store context\n");
        wolfSSL_X509_STORE_free(store);
        wolfSSL_X509_free(icaCert);
        wolfSSL_X509_free(serverCert);
        return -1;
    }
    if (wolfSSL_X509_STORE_add_cert(store, icaCert) != SSL_SUCCESS) {
        printf("Error adding intermediate CA certificate to store\n");
        wolfSSL_X509_STORE_CTX_free(ctx);
        wolfSSL_X509_STORE_free(store);
        wolfSSL_X509_free(icaCert);
        wolfSSL_X509_free(serverCert);
        return -1;
    }

    if (wolfSSL_X509_STORE_CTX_init(ctx, store, serverCert, NULL) != SSL_SUCCESS) {
        printf("Error initializing X509 store context\n");
        wolfSSL_X509_STORE_CTX_free(ctx);
        wolfSSL_X509_STORE_free(store);
        wolfSSL_X509_free(icaCert);
        wolfSSL_X509_free(serverCert);
        return -1;
    }

    verifyResult = wolfSSL_X509_verify_cert(ctx);
    if (verifyResult != SSL_SUCCESS) {
        printf("Certificate chain verification failed: %d\n", verifyResult);
    } else {
        printf("Certificate chain verification succeeded\n");
    }
    
    wolfSSL_X509_STORE_CTX_free(ctx);
    wolfSSL_X509_STORE_free(store);
    wolfSSL_X509_free(icaCert);
    wolfSSL_X509_free(serverCert);
    wolfSSL_Cleanup();

    return 0;
}

---------
certverify-standalone

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#ifdef HAVE_CONFIG_H
    #include <config.h>
#endif
/* wolfSSL */
#include <wolfssl/options.h>
#include <wolfssl/wolfcrypt/settings.h>
#include <wolfssl/wolfcrypt/asn_public.h>
#include <wolfssl/wolfcrypt/asn.h>
#include <wolfssl/wolfcrypt/error-crypt.h>
#include <wolfssl/ssl.h>
#include <wolfssl/test.h>
#include <time.h>

#include <sys/types.h>
#include <sys/stat.h>
#define BUFFER_SZ 60000

#ifndef WOLFSSL_DEBUG_TLS
    #define WOLFSSL_DEBUG_TLS   /* enable full debugging */
#endif
#ifndef DEBUG_WOLFSSL
    #define DEBUG_WOLFSSL
#endif
#ifndef WOLFSSL_CERT_EXT
    #define WOLFSSL_CERT_EXT
#endif

//enable dilithium
#if defined(HAVE_DILITHIUM)
#include <stdint.h>
#include <wolfssl/wolfcrypt/hash.h>
#include <wolfssl/wolfcrypt/dilithium.h>
#include <wolfssl/wolfcrypt/dilithium_packing.h>
#include <wolfssl/wolfcrypt/dilithium_polynoms.h>
#include <wolfssl/wolfcrypt/dilithium_symmetric.h>

int main()
{
    WOLFSSL_X509 *cert;
    WOLFSSL_X509_STORE *store;
    WOLFSSL_X509_STORE_CTX *ctx;
    int verifyResult;
    
    // Initialize WolfSSL
    if (wolfSSL_Init() != SSL_SUCCESS) {
        printf("Error initializing WolfSSL\n");
        return -1;
    }
    
    // Load the CA certificate (or trusted root certificate)
    store = wolfSSL_X509_STORE_new();
    if (store == NULL) {
        printf("Error creating X509 store\n");
        return -1;
    }
    
    if (wolfSSL_X509_STORE_load_locations(store, "rootcert.pem", NULL) != SSL_SUCCESS) {
        printf("Error loading CA certificate\n");
        wolfSSL_X509_STORE_free(store);
        return -1;
    }
    
    // Load the certificate to be verified
    cert = wolfSSL_X509_load_certificate_file("icacert.pem", SSL_FILETYPE_PEM);
    if (cert == NULL) {
        printf("Error loading certificate\n");
        wolfSSL_X509_STORE_free(store);
        return -1;
    }

    // Initialize the X509 store context
    ctx = wolfSSL_X509_STORE_CTX_new();
    if (ctx == NULL) {
        printf("Error creating X509 store context\n");
        wolfSSL_X509_free(cert);
        wolfSSL_X509_STORE_free(store);
        return -1;
    }
    
    // Initialize the context with store and certificate
    if (wolfSSL_X509_STORE_CTX_init(ctx, store, cert, NULL) != SSL_SUCCESS) {
        printf("Error initializing X509 store context\n");
        wolfSSL_X509_free(cert);
        wolfSSL_X509_STORE_free(store);
        wolfSSL_X509_STORE_CTX_free(ctx);
        return -1;
    }
    
    // Verify the certificate
    verifyResult = wolfSSL_X509_verify_cert(ctx);
    if (verifyResult != SSL_SUCCESS) {
        printf("Certificate verification failed: %d\n", verifyResult);
    } else {
        printf("Certificate verification succeeded\n");
    }
    
    // Clean up resources
    wolfSSL_X509_STORE_CTX_free(ctx);
    wolfSSL_X509_free(cert);
    wolfSSL_X509_STORE_free(store);
    
    // Clean up WolfSSL
    wolfSSL_Cleanup();
    
    return 0;
}
#endif


